== Bucketing

*Bucketing* is a mechanism to _hash-partition_ a data set into *buckets* per *bucketing columns*.

The motivation is to optimize performance of a join query by avoiding shuffles (aka _exchanges_) of tables participating in the join. Bucketing also results in fewer exchanges (and so stages).

NOTE: Bucketing can show the biggest benefit when *pre-shuffled bucketed tables* are used more than once as bucketing itself takes time (that you will offset executing multiple join queries later).

[source, scala]
----
// Example: SortMergeJoin of two FileScans

// Make sure that you don't end up with a BroadcastHashJoin and a BroadcastExchange
// Disable auto broadcasting, e.g. spark.sql.autoBroadcastJoinThreshold
spark.conf.set("spark.sql.autoBroadcastJoinThreshold", -1)

scala> spark.catalog.listTables.show
+-----+--------+-----------+---------+-----------+
| name|database|description|tableType|isTemporary|
+-----+--------+-----------+---------+-----------+
|a10e6| default|       null|  MANAGED|      false|
|a10e8| default|       null|  MANAGED|      false|
+-----+--------+-----------+---------+-----------+

val t1 = spark.table("a10e6")
val t2 = spark.table("a10e8")

// trigger execution of the join query
t1.join(t2, "id").foreach(_ => ())
----

The above join query is a fine example of a link:spark-sql-SparkPlan-SortMergeJoinExec.adoc[SortMergeJoinExec] (aka _SortMergeJoin_) of two link:spark-sql-SparkPlan-FileSourceScanExec.adoc[FileSourceScanExecs] (aka _Scan_). The join query uses link:spark-sql-SparkPlan-ShuffleExchangeExec.adoc[ShuffleExchangeExec] physical operators (aka _Exchange_) to shuffle the table datasets for the SortMergeJoin.

.SortMergeJoin of FileScans (Details for Query)
image::images/spark-sql-bucketing-sortmergejoin-filescans.png[align="center"]

Bucketing is applicable for all file-based data sources, e.g. Parquet, JSON.

You use link:spark-sql-DataFrameWriter.adoc#bucketBy[DataFrameWriter.bucketBy] method to specify the number of buckets and the bucketing columns (that end up as a link:spark-sql-BucketSpec.adoc[BucketSpec] internally).

[source, scala]
----
peopleDF.write
  .bucketBy(42, "name")
  .sortBy("age")
  .saveAsTable("people_bucketed")
----

Unlike bucketing in Apache Hive, Spark SQL creates the bucket files per the number of buckets and partitions. In other words, the number of bucketing files is the number of buckets multiplied by the number of task writers (one per partition).

```
val large = spark.range(100000000)

scala> large.write.bucketBy(8, "id").saveAsTable("buckets_8_10e8")
18/04/17 12:19:25 WARN HiveExternalCatalog: Persisting bucketed data source table `default`.`buckets_8_10e8` into Hive metastore in Spark SQL specific format, which is NOT compatible with Hive.

scala> println(large.queryExecution.toRdd.getNumPartitions)
8

// That gives 8 (partitions/task writers) x 8 (buckets) = 64 files
// With _SUCCESS extra file and the ls -l header "total 794624" that gives 66 files
$ ls -tlr spark-warehouse/buckets_8_10e8 | wc -l
      66
```

After you bucketed the table data sets, you should notice that the Exchanges are no longer needed (as the tables are already pre-shuffled).

[source, scala]
----
// Note that the example uses the bucketed tables
val t1 = spark.table("buckets_8_10e6")
val t2 = spark.table("buckets_8_10e8")

// trigger execution of the join query
t1.join(t2, "id").foreach(_ => ())
----

The above join query of the bucketed tables shows no link:spark-sql-SparkPlan-ShuffleExchangeExec.adoc[ShuffleExchangeExec] physical operators (aka _Exchange_) as the shuffling has already been executed (before the query was run).

.SortMergeJoin of Bucketed Tables (Details for Query)
image::images/spark-sql-bucketing-sortmergejoin-bucketed-tables-no-exchanges.png[align="center"]

The number of partitions of a bucketed table is exactly the number of buckets.

[source, scala]
----
// FIXME Show the number of buckets
val table = spark.table("bucketed_table")
val rdd = table.queryExecution.toRdd
println(rdd.partitions.length)
----

Use link:spark-sql-SessionCatalog.adoc#getTableMetadata[SessionCatalog] or `DESCRIBE EXTENDED` SQL command to find the bucket information.

[source, scala]
----
scala> spark.catalog.listTables.show(false)
+---------------------+--------+-----------+---------+-----------+
|name                 |database|description|tableType|isTemporary|
+---------------------+--------+-----------+---------+-----------+
|buckets_8_10e6_sorted|default |null       |MANAGED  |false      |
+---------------------+--------+-----------+---------+-----------+

scala> sql("DESCRIBE EXTENDED buckets_8_10e6_sorted").show(21, false)
+----------------------------+---------------------------------------------------------------------+-------+
|col_name                    |data_type                                                            |comment|
+----------------------------+---------------------------------------------------------------------+-------+
|id                          |bigint                                                               |null   |
|                            |                                                                     |       |
|# Detailed Table Information|                                                                     |       |
|Database                    |default                                                              |       |
|Table                       |buckets_8_10e6_sorted                                                |       |
|Owner                       |jacek                                                                |       |
|Created Time                |Tue Apr 17 18:42:37 CEST 2018                                        |       |
|Last Access                 |Thu Jan 01 01:00:00 CET 1970                                         |       |
|Created By                  |Spark 2.3.1-SNAPSHOT                                                 |       |
|Type                        |MANAGED                                                              |       |
|Provider                    |parquet                                                              |       |
|Num Buckets                 |8                                                                    |       |
|Bucket Columns              |[`id`]                                                               |       |
|Sort Columns                |[`id`]                                                               |       |
|Table Properties            |[transient_lastDdlTime=1523983357]                                   |       |
|Statistics                  |4055953 bytes                                                        |       |
|Location                    |file:/Users/jacek/dev/oss/spark/spark-warehouse/buckets_8_10e6_sorted|       |
|Serde Library               |org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe                   |       |
|InputFormat                 |org.apache.hadoop.mapred.SequenceFileInputFormat                     |       |
|OutputFormat                |org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat            |       |
|Storage Properties          |[serialization.format=1]                                             |       |
+----------------------------+---------------------------------------------------------------------+-------+

import org.apache.spark.sql.catalyst.TableIdentifier
val metadata = spark.sessionState.catalog.getTableMetadata(TableIdentifier("buckets_8_10e6_sorted"))
scala> metadata.bucketSpec.foreach(println)
8 buckets, bucket columns: [id], sort columns: [id]
----

The link:spark-sql-BucketSpec.adoc#numBuckets[number of buckets] has to be between `0` and `100000` exclusive or Spark SQL reports an `AnalysisException`:

```
Number of buckets should be greater than 0 but less than 100000. Got `[numBuckets]`
```
