== [[TreeNode]] TreeNode -- Node in Catalyst Tree

`TreeNode` is a node in link:spark-sql-catalyst.adoc[Catalyst] tree with zero or more <<children, children>> (and can build link:spark-sql-Expression.adoc[expression] or link:spark-sql-catalyst-QueryPlan.adoc[structured query plan] trees).

`TreeNode` offers not only functions that you may have used from Scala Collection API, e.g. `map`, `flatMap`, `collect`, `collectFirst`, `foreach`, but also `mapChildren`, `transform`, `transformDown`, `transformUp`, `foreachUp`, `numberedTreeString`, `p`, `asCode`, `prettyJson`, etc. for tree manipulation or debugging.

NOTE: Scala-specific, `TreeNode` is an abstract class that is the base class of link:spark-sql-Expression.adoc[Expression] and Catalyst's link:spark-sql-catalyst-QueryPlan.adoc[QueryPlan] abstract classes.

[TIP]
====
`TreeNode` abstract type is a quite advanced Scala type definition (at least comparing to the other Scala types in Spark) so understanding its behaviour even outside Spark might be worthwhile by itself.

[source, scala]
----
abstract class TreeNode[BaseType <: TreeNode[BaseType]] extends Product {
  self: BaseType =>

  // ...
}
----
====

[[nodeName]]
`TreeNode` has a *node name* as `nodeName`.

=== [[contract]] TreeNode Contract

[source, scala]
----
package org.apache.spark.sql.catalyst.trees

abstract class TreeNode[BaseType <: TreeNode[BaseType]] extends Product {
  self: BaseType =>

  // only required methods that have no implementation
  // the others follow
  def children: Seq[BaseType]
  def verboseString: String
}
----

.(Subset of) TreeNode Contract
[cols="1,2",options="header",width="100%"]
|===
| Method
| Description

| `children`
| [[children]] Child nodes

| `verboseString`
| [[verboseString]] One-line *verbose description*

Used when `TreeNode` is requested for <<generateTreeString, generateTreeString>> (with `verbose` flag enabled) and <<verboseStringWithSuffix, verboseStringWithSuffix>>
|===

=== [[withNewChildren]] `withNewChildren` Method

[source, scala]
----
withNewChildren(newChildren: Seq[BaseType]): BaseType
----

`withNewChildren`...FIXME

NOTE: `withNewChildren` is used when...FIXME

=== [[simpleString]] Simple Node Description -- `simpleString` Method

[source, scala]
----
simpleString: String
----

`simpleString` gives a simple one-line description of a `TreeNode`.

Internally, `simpleString` is the <<nodeName, nodeName>> followed by <<argString, argString>> separated by a single white space.

NOTE: `simpleString` is used when `TreeNode` is requested for <<argString, argString>> (of child nodes) and <<generateTreeString, tree text representation>> (with `verbose` flag off).

=== [[numberedTreeString]] Numbered Text Representation -- `numberedTreeString` Method

[source, scala]
----
numberedTreeString: String
----

`numberedTreeString` adds numbers to the <<treeString, text representation of all the nodes>>.

NOTE: `numberedTreeString` is used primarily for interactive debugging using <<apply, apply>> and <<p, p>> methods.

=== [[apply]] Getting n-th TreeNode in Tree (for Interactive Debugging) -- `apply` Method

[source, scala]
----
apply(number: Int): TreeNode[_]
----

`apply` gives `number`-th tree node in a tree.

NOTE: `apply` can be used for interactive debugging.

Internally, `apply` <<getNodeNumbered, gets the node>> at `number` position or `null`.

=== [[p]] Getting n-th BaseType in Tree (for Interactive Debugging) -- `p` Method

[source, scala]
----
p(number: Int): BaseType
----

`p` gives `number`-th tree node in a tree as `BaseType` for interactive debugging.

NOTE: `p` can be used for interactive debugging.

[NOTE]
====
`BaseType` is the base type of a tree and in Spark SQL can be:

* link:spark-sql-LogicalPlan.adoc[LogicalPlan] for logical plan trees

* link:spark-sql-SparkPlan.adoc[SparkPlan] for physical plan trees

* link:spark-sql-Expression.adoc[Expression] for expression trees
====

=== [[toString]] Text Representation -- `toString` Method

[source, scala]
----
toString: String
----

NOTE: `toString` is part of Java's link:++https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString--++[Object Contract] for the string representation of an object, e.g. `TreeNode`.

`toString` simply returns the <<treeString, text representation of all nodes in the tree>>.

=== [[treeString]] Text Representation of All Nodes in Tree -- `treeString` Method

[source, scala]
----
treeString: String  // <1>
treeString(verbose: Boolean, addSuffix: Boolean = false): String
----
<1> Turns verbose flag on

`treeString` gives the string representation of all the nodes in the `TreeNode`.

[source, scala]
----
import org.apache.spark.sql.{functions => f}
val q = spark.range(10).withColumn("rand", f.rand())
val executedPlan = q.queryExecution.executedPlan

val output = executedPlan.treeString(verbose = true)

scala> println(output)
*(1) Project [id#0L, rand(6790207094253656854) AS rand#2]
+- *(1) Range (0, 10, step=1, splits=8)
----

[NOTE]
====
`treeString` is used when:

* `TreeNode` is requested for the <<numberedTreeString, numbered text representation>> and the <<toString, text representation>>

* `QueryExecution` is requested for link:spark-sql-QueryExecution.adoc#simpleString[simple], link:spark-sql-QueryExecution.adoc#toString[extended] and link:spark-sql-QueryExecution.adoc#stringWithStats[with statistics] text representations
====

=== [[verboseStringWithSuffix]] Verbose Description with Suffix -- `verboseStringWithSuffix` Method

[source, scala]
----
verboseStringWithSuffix: String
----

`verboseStringWithSuffix` simply returns <<verboseString, verbose description>>.

NOTE: `verboseStringWithSuffix` is used exclusively when `TreeNode` is requested to <<generateTreeString, generateTreeString>> (with `verbose` and `addSuffix` flags enabled).

=== [[generateTreeString]] Generating Text Representation of Inner and Regular Child Nodes -- `generateTreeString` Method

[source, scala]
----
generateTreeString(
  depth: Int,
  lastChildren: Seq[Boolean],
  builder: StringBuilder,
  verbose: Boolean,
  prefix: String = "",
  addSuffix: Boolean = false): StringBuilder
----

Internally, `generateTreeString` appends the following node descriptions per the `verbose` and `addSuffix` flags:

* <<verboseStringWithSuffix, verbose description with suffix>> when both are enabled (i.e. `verbose` and `addSuffix` flags are all `true`)

* <<verboseString, verbose description>> when `verbose` is enabled (i.e. `verbose` is `true` and `addSuffix` is `false`)

* <<simpleString, simple description>> when `verbose` is disabled (i.e. `verbose` is `false`)

In the end, `generateTreeString` calls itself recursively for the <<innerChildren, innerChildren>> and the <<children, child nodes>>.

NOTE: `generateTreeString` is used exclusively when `TreeNode` is requested for <<treeString, text representation of all nodes in the tree>>.

=== [[innerChildren]] `innerChildren` Method

[source, scala]
----
innerChildren: Seq[TreeNode[_]]
----

`innerChildren` simply returns an empty collection of `TreeNodes`.

[NOTE]
====
`innerChildren` is used when:

* `TreeNode` is requested to <<generateTreeString, generate the text representation of inner and regular child nodes>>, <<allChildren, allChildren>> and <<getNodeNumbered, getNodeNumbered>>

* `InMemoryTableScanExec` is requested for link:spark-sql-SparkPlan-InMemoryTableScanExec.adoc#innerChildren[innerChildren]
====

=== [[allChildren]] `allChildren` Property

[source, scala]
----
allChildren: Set[TreeNode[_]]
----

NOTE: `allChildren` is a Scala lazy value which is computed once when accessed and cached afterwards.

`allChildren`...FIXME

NOTE: `allChildren` is used when...FIXME

=== [[getNodeNumbered]] `getNodeNumbered` Internal Method

[source, scala]
----
getNodeNumbered(number: MutableInt): Option[TreeNode[_]]
----

`getNodeNumbered`...FIXME

NOTE: `getNodeNumbered` is used when...FIXME
